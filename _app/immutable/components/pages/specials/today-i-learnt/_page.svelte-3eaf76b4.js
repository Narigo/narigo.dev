import{S as ve,i as we,s as ye,w as fe,x as ce,y as me,f as ue,t as pe,z as ge,k as a,q as e,a as _,l as r,m as i,r as o,h as n,c as b,n as x,b as K,G as t}from"../../../../chunks/index-1eaa4f41.js";import{b as _e}from"../../../../chunks/paths-b4419565.js";import{N as be}from"../../../../chunks/Narigo-79588e20.js";import{P as Ee}from"../../../../chunks/PageLayout-7674fa64.js";function ke(T){let s;return{c(){s=e(`To remember more of the little things I learn, I want to write them down. I'll update this page
		whenever I find something worth to log. Most of this will be around web development, but I don't
		want to limit myself to that. Let's see where this leads to.`)},l(f){s=o(f,`To remember more of the little things I learn, I want to write them down. I'll update this page
		whenever I find something worth to log. Most of this will be around web development, but I don't
		want to limit myself to that. Let's see where this leads to.`)},m(f,d){K(f,s,d)},d(f){f&&n(s)}}}function Ie(T){let s,f,d,c,k,u,I,H,et,ot,g,nt,$,at,rt,z,it,lt,W,st,C,dt,ht,ft,S,A,ct,mt,h,ut,L,pt,gt,B,vt,wt,q,yt,_t,J,bt,Et,O,kt,jt="{ height: 100% }",It,$t,zt,F,M,Ct,St,P,Ft,N,Dt,xt,D,U,Wt,Lt,m,Ot,Q,Pt,Kt="{ ... }",Qt,Tt,V,Ht,At,G,Bt,qt,j,Jt,Mt,R;return c=new be({props:{$$slots:{default:[ke]},$$scope:{ctx:T}}}),{c(){s=a("h2"),f=e("Today I learnt"),d=_(),fe(c.$$.fragment),k=_(),u=a("ul"),I=a("li"),H=a("h3"),et=e("Drawing with linear gradients"),ot=_(),g=a("p"),nt=e("In "),$=a("a"),at=e("VirtualCoffee.io"),rt=e(` Frontend Friday
				Folks, we have to create divs that resemble a given image on
				`),z=a("a"),it=e("CSSBattle.dev"),lt=e(`. Lately, I've tried to do
				the puzzles by styling them with
				`),W=a("code"),st=e("background: "),C=a("a"),dt=e("linear-gradient()"),ht=e(`. When you find out a way how to draw it like that, it always feels like a hack of the
				puzzle itself.`),ft=_(),S=a("li"),A=a("h3"),ct=e("srcdoc sets an iframes doctype implicitly, Quirks mode expands the body height"),mt=_(),h=a("p"),ut=e("When working on the Puzzle iframe for the "),L=a("a"),pt=e("Frontend Friday Folks"),gt=e(`, I had trouble centering the image. I had the same code result in the Chrome Dev Tools as
				in CSSBattle.dev, when inspecting the elements, so I didn't realize why it still looked
				different. It looks like when using the `),B=a("code"),vt=e("srcdoc"),wt=e(" on an "),q=a("code"),yt=e("iframe"),_t=e(`
				element, the iframe sets the doctype implicitly. When writing into the iframe through
				`),J=a("code"),bt=e("contentWindow.write"),Et=e(`, it doesn't set a doctype for the iframe and hence it stays
				in Quirks mode. Quirks mode seems to expand the body height, without having to set
				`),O=a("code"),kt=e("html,body "),It=e(jt),$t=e(" or something similar."),zt=_(),F=a("li"),M=a("h3"),Ct=e("`::before` and `::after` are siblings, nested and `display: inline` in a div"),St=_(),P=a("p"),Ft=e(`I can never really remember how they work and during this Frontend Friday Folks puzzle, we
				looked into that again. It seems to be easier to nest divs than using the pseudo elements
				here. So to understand it better: `),N=a("code"),Dt=e(`<div><::before>content in ::before</::before>content of
					div<::after>content in ::after</::after></div>`),xt=_(),D=a("li"),U=a("h3"),Wt=e("Strings in JavaScript are iterable without using `split`"),Lt=_(),m=a("p"),Ot=e("When using "),Q=a("code"),Pt=e("for (const c of string) "),Qt=e(Kt),Tt=e(`, it's not necessary to do a
				`),V=a("code"),Ht=e("string.split('')"),At=e(`
				before. If you want to `),G=a("code"),Bt=e("string.map()"),qt=e(" or "),j=a("code"),Jt=e("string.filter()"),Mt=e(` though, you
				need to split it first.`),this.h()},l(l){s=r(l,"H2",{});var v=i(s);f=o(v,"Today I learnt"),v.forEach(n),d=b(l),ce(c.$$.fragment,l),k=b(l),u=r(l,"UL",{});var w=i(u);I=r(w,"LI",{});var X=i(I);H=r(X,"H3",{});var Rt=i(H);et=o(Rt,"Drawing with linear gradients"),Rt.forEach(n),ot=b(X),g=r(X,"P",{});var E=i(g);nt=o(E,"In "),$=r(E,"A",{href:!0,rel:!0});var Xt=i($);at=o(Xt,"VirtualCoffee.io"),Xt.forEach(n),rt=o(E,` Frontend Friday
				Folks, we have to create divs that resemble a given image on
				`),z=r(E,"A",{href:!0,rel:!0});var Yt=i(z);it=o(Yt,"CSSBattle.dev"),Yt.forEach(n),lt=o(E,`. Lately, I've tried to do
				the puzzles by styling them with
				`),W=r(E,"CODE",{});var Nt=i(W);st=o(Nt,"background: "),C=r(Nt,"A",{href:!0,rel:!0});var Zt=i(C);dt=o(Zt,"linear-gradient()"),Zt.forEach(n),Nt.forEach(n),ht=o(E,`. When you find out a way how to draw it like that, it always feels like a hack of the
				puzzle itself.`),E.forEach(n),X.forEach(n),ft=b(w),S=r(w,"LI",{});var Y=i(S);A=r(Y,"H3",{});var te=i(A);ct=o(te,"srcdoc sets an iframes doctype implicitly, Quirks mode expands the body height"),te.forEach(n),mt=b(Y),h=r(Y,"P",{});var p=i(h);ut=o(p,"When working on the Puzzle iframe for the "),L=r(p,"A",{href:!0});var ee=i(L);pt=o(ee,"Frontend Friday Folks"),ee.forEach(n),gt=o(p,`, I had trouble centering the image. I had the same code result in the Chrome Dev Tools as
				in CSSBattle.dev, when inspecting the elements, so I didn't realize why it still looked
				different. It looks like when using the `),B=r(p,"CODE",{});var oe=i(B);vt=o(oe,"srcdoc"),oe.forEach(n),wt=o(p," on an "),q=r(p,"CODE",{});var ne=i(q);yt=o(ne,"iframe"),ne.forEach(n),_t=o(p,`
				element, the iframe sets the doctype implicitly. When writing into the iframe through
				`),J=r(p,"CODE",{});var ae=i(J);bt=o(ae,"contentWindow.write"),ae.forEach(n),Et=o(p,`, it doesn't set a doctype for the iframe and hence it stays
				in Quirks mode. Quirks mode seems to expand the body height, without having to set
				`),O=r(p,"CODE",{});var Ut=i(O);kt=o(Ut,"html,body "),It=o(Ut,jt),Ut.forEach(n),$t=o(p," or something similar."),p.forEach(n),Y.forEach(n),zt=b(w),F=r(w,"LI",{});var Z=i(F);M=r(Z,"H3",{});var re=i(M);Ct=o(re,"`::before` and `::after` are siblings, nested and `display: inline` in a div"),re.forEach(n),St=b(Z),P=r(Z,"P",{});var Vt=i(P);Ft=o(Vt,`I can never really remember how they work and during this Frontend Friday Folks puzzle, we
				looked into that again. It seems to be easier to nest divs than using the pseudo elements
				here. So to understand it better: `),N=r(Vt,"CODE",{});var ie=i(N);Dt=o(ie,`<div><::before>content in ::before</::before>content of
					div<::after>content in ::after</::after></div>`),ie.forEach(n),Vt.forEach(n),Z.forEach(n),xt=b(w),D=r(w,"LI",{});var tt=i(D);U=r(tt,"H3",{});var le=i(U);Wt=o(le,"Strings in JavaScript are iterable without using `split`"),le.forEach(n),Lt=b(tt),m=r(tt,"P",{});var y=i(m);Ot=o(y,"When using "),Q=r(y,"CODE",{});var Gt=i(Q);Pt=o(Gt,"for (const c of string) "),Qt=o(Gt,Kt),Gt.forEach(n),Tt=o(y,`, it's not necessary to do a
				`),V=r(y,"CODE",{});var se=i(V);Ht=o(se,"string.split('')"),se.forEach(n),At=o(y,`
				before. If you want to `),G=r(y,"CODE",{});var de=i(G);Bt=o(de,"string.map()"),de.forEach(n),qt=o(y," or "),j=r(y,"CODE",{});var he=i(j);Jt=o(he,"string.filter()"),he.forEach(n),Mt=o(y,` though, you
				need to split it first.`),y.forEach(n),tt.forEach(n),w.forEach(n),this.h()},h(){x($,"href","https://virtualcoffee.io/"),x($,"rel","external"),x(z,"href","https://cssbattle.dev/"),x(z,"rel","external"),x(C,"href","https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient"),x(C,"rel","external"),x(L,"href",_e+"/specials/frontend-friday-folks")},m(l,v){K(l,s,v),t(s,f),K(l,d,v),me(c,l,v),K(l,k,v),K(l,u,v),t(u,I),t(I,H),t(H,et),t(I,ot),t(I,g),t(g,nt),t(g,$),t($,at),t(g,rt),t(g,z),t(z,it),t(g,lt),t(g,W),t(W,st),t(W,C),t(C,dt),t(g,ht),t(u,ft),t(u,S),t(S,A),t(A,ct),t(S,mt),t(S,h),t(h,ut),t(h,L),t(L,pt),t(h,gt),t(h,B),t(B,vt),t(h,wt),t(h,q),t(q,yt),t(h,_t),t(h,J),t(J,bt),t(h,Et),t(h,O),t(O,kt),t(O,It),t(h,$t),t(u,zt),t(u,F),t(F,M),t(M,Ct),t(F,St),t(F,P),t(P,Ft),t(P,N),t(N,Dt),t(u,xt),t(u,D),t(D,U),t(U,Wt),t(D,Lt),t(D,m),t(m,Ot),t(m,Q),t(Q,Pt),t(Q,Qt),t(m,Tt),t(m,V),t(V,Ht),t(m,At),t(m,G),t(G,Bt),t(m,qt),t(m,j),t(j,Jt),t(m,Mt),R=!0},p(l,v){const w={};v&1&&(w.$$scope={dirty:v,ctx:l}),c.$set(w)},i(l){R||(ue(c.$$.fragment,l),R=!0)},o(l){pe(c.$$.fragment,l),R=!1},d(l){l&&n(s),l&&n(d),ge(c,l),l&&n(k),l&&n(u)}}}function $e(T){let s,f;return s=new Ee({props:{$$slots:{default:[Ie]},$$scope:{ctx:T}}}),{c(){fe(s.$$.fragment)},l(d){ce(s.$$.fragment,d)},m(d,c){me(s,d,c),f=!0},p(d,[c]){const k={};c&1&&(k.$$scope={dirty:c,ctx:d}),s.$set(k)},i(d){f||(ue(s.$$.fragment,d),f=!0)},o(d){pe(s.$$.fragment,d),f=!1},d(d){ge(s,d)}}}class De extends ve{constructor(s){super(),we(this,s,null,$e,ye,{})}}export{De as default};
