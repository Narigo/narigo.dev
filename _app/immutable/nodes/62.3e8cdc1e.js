import{s as g,a as h,c as _,i as p,d,l as v,m as z}from"../chunks/scheduler.750b9d5e.js";import{S as y,i as b,b as i,d as u,m as l,a as f,t as m,e as c}from"../chunks/index.369e6c44.js";import{N as x}from"../chunks/Narigo.2253bd05.js";import{P as I,a as P}from"../chunks/PuzzlePageLayout.50f89189.js";function w(s){let t;return{c(){t=v(`This was quite hard to do. I've used gradients only and one div for the head. Since most parts
		of the gradients are the same, I've used variables extensively. I learned that you cannot use a
		variable to start off a function and another one to close it. You can put the arguments into a
		variable, if you need them though.`)},l(n){t=z(n,`This was quite hard to do. I've used gradients only and one div for the head. Since most parts
		of the gradients are the same, I've used variables extensively. I learned that you cannot use a
		variable to start off a function and another one to close it. You can put the arguments into a
		variable, if you need them though.`)},m(n,e){p(n,t,e)},d(n){n&&d(t)}}}function S(s){let t,n,e,o;return t=new P({props:{title:"Puzzle 74 solution",solution:s[0]}}),e=new x({props:{$$slots:{default:[w]},$$scope:{ctx:s}}}),{c(){i(t.$$.fragment),n=h(),i(e.$$.fragment)},l(a){u(t.$$.fragment,a),n=_(a),u(e.$$.fragment,a)},m(a,r){l(t,a,r),p(a,n,r),l(e,a,r),o=!0},p(a,r){const $={};r&2&&($.$$scope={dirty:r,ctx:a}),e.$set($)},i(a){o||(f(t.$$.fragment,a),f(e.$$.fragment,a),o=!0)},o(a){m(t.$$.fragment,a),m(e.$$.fragment,a),o=!1},d(a){a&&d(n),c(t,a),c(e,a)}}}function q(s){let t,n;return t=new I({props:{title:"Danger Noodle",$$slots:{default:[S]},$$scope:{ctx:s}}}),{c(){i(t.$$.fragment)},l(e){u(t.$$.fragment,e)},m(e,o){l(t,e,o),n=!0},p(e,[o]){const a={};o&2&&(a.$$scope={dirty:o,ctx:e}),t.$set(a)},i(e){n||(f(t.$$.fragment,e),n=!0)},o(e){m(t.$$.fragment,e),n=!1},d(e){c(t,e)}}}function N(s){return[""]}class L extends y{constructor(t){super(),b(this,t,N,q,g,{})}}export{L as component};
