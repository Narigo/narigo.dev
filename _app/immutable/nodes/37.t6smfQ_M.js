import{s as x,a as b,c as w,i as l,d as u,l as g,m as h}from"../chunks/scheduler.Po0zCuFf.js";import{S as _,i as z,b as f,d,m as c,a as p,t as $,e as m}from"../chunks/index.WEWm72Kh.js";import{C as y}from"../chunks/Code.GrnAcMCy.js";import{N as v}from"../chunks/Narigo.BzClmAmS.js";import{P as k,a as I}from"../chunks/PuzzlePageLayout.m2K0EG3i.js";function C(i){let e;return{c(){e=g("-webkit-box-reflect")},l(s){e=h(s,"-webkit-box-reflect")},m(s,o){l(s,e,o)},d(s){s&&u(e)}}}function A(i){let e,s,o,n;return s=new y({props:{$$slots:{default:[C]},$$scope:{ctx:i}}}),{c(){e=g("Finally I had a puzzle where I could use "),f(s.$$.fragment),o=g(`. I now know that it
		doesn't span a size, so centering something is not as easy, if you want the reflection to be
		counted as well. I used selectors instead of classes and ids this time, just to not having to
		name the boxes.`)},l(t){e=h(t,"Finally I had a puzzle where I could use "),d(s.$$.fragment,t),o=h(t,`. I now know that it
		doesn't span a size, so centering something is not as easy, if you want the reflection to be
		counted as well. I used selectors instead of classes and ids this time, just to not having to
		name the boxes.`)},m(t,a){l(t,e,a),c(s,t,a),l(t,o,a),n=!0},p(t,a){const r={};a&2&&(r.$$scope={dirty:a,ctx:t}),s.$set(r)},i(t){n||(p(s.$$.fragment,t),n=!0)},o(t){$(s.$$.fragment,t),n=!1},d(t){t&&(u(e),u(o)),m(s,t)}}}function P(i){let e,s,o,n;return e=new I({props:{title:"Puzzle 45 solution",solution:i[0]}}),o=new v({props:{$$slots:{default:[A]},$$scope:{ctx:i}}}),{c(){f(e.$$.fragment),s=b(),f(o.$$.fragment)},l(t){d(e.$$.fragment,t),s=w(t),d(o.$$.fragment,t)},m(t,a){c(e,t,a),l(t,s,a),c(o,t,a),n=!0},p(t,a){const r={};a&2&&(r.$$scope={dirty:a,ctx:t}),o.$set(r)},i(t){n||(p(e.$$.fragment,t),p(o.$$.fragment,t),n=!0)},o(t){$(e.$$.fragment,t),$(o.$$.fragment,t),n=!1},d(t){t&&u(s),m(e,t),m(o,t)}}}function F(i){let e,s;return e=new k({props:{title:"Magical Tree",$$slots:{default:[P]},$$scope:{ctx:i}}}),{c(){f(e.$$.fragment)},l(o){d(e.$$.fragment,o)},m(o,n){c(e,o,n),s=!0},p(o,[n]){const t={};n&2&&(t.$$scope={dirty:n,ctx:o}),e.$set(t)},i(o){s||(p(e.$$.fragment,o),s=!0)},o(o){$(e.$$.fragment,o),s=!1},d(o){m(e,o)}}}function j(i){return[`<div>
  <div></div>
</div>
<dt></dt>
<style>
  body {
    background: #1A4341;
    box-sizing: border-box;
    border-left: 65px solid #1A4341;
    margin: 0;
  }
  body>div {
    border: 30px solid #F3AC3C;
    border-top-width: 0;
    border-right-width: 15px;
    display: flex;
    justify-content: flex-end;
    width: 90px;
    height: 180px;
    -webkit-box-reflect: right;
  }
  div>div {
    border-left: 30px solid #998235;
    border-bottom: 30px solid #998235;
    height: 120px;
    width: 30px;
  }
  dt {
    background: linear-gradient(#1A4341 30px, #998235 0 60px, #1A4341 30px);
    border-right: 15px solid #F3AC3C;
    height: 90px;
    width: 120px;
    -webkit-box-reflect: right;
  }
</style>
`]}class T extends _{constructor(e){super(),z(this,e,j,F,x,{})}}export{T as component};
