import{s as P,a as b,c as k,i as g,d as c,l as F,m as y}from"../chunks/scheduler.oS2FPi-b.js";import{S as I,i as E,b as p,d as u,m as d,a as f,t as m,e as $}from"../chunks/index.ICQ99_FX.js";import{N as z}from"../chunks/Narigo.3rfA2dqH.js";import{P as C,a as v}from"../chunks/PuzzlePageLayout.tFVPNozX.js";function A(r){let e;return{c(){e=F(`I'm not sure whether webkit-box-reflect helps too much here. What I don't like is having the
		mouth part. I'd like to know how this can be calculated instead of having to try and test lots
		of values until something works for 100%.`)},l(a){e=y(a,`I'm not sure whether webkit-box-reflect helps too much here. What I don't like is having the
		mouth part. I'd like to know how this can be calculated instead of having to try and test lots
		of values until something works for 100%.`)},m(a,o){g(a,e,o)},d(a){a&&c(e)}}}function N(r){let e;return{c(){e=F("Ok, using another radial gradient makes sense instead of adding another element.")},l(a){e=y(a,"Ok, using another radial gradient makes sense instead of adding another element.")},m(a,o){g(a,e,o)},d(a){a&&c(e)}}}function O(r){let e,a,o,s,i,h,l,x;return e=new v({props:{title:"Puzzle 70 solution",solution:r[0]}}),o=new z({props:{$$slots:{default:[A]},$$scope:{ctx:r}}}),i=new v({props:{title:"Puzzle 70 solution",solution:r[1]}}),l=new z({props:{$$slots:{default:[N]},$$scope:{ctx:r}}}),{c(){p(e.$$.fragment),a=b(),p(o.$$.fragment),s=b(),p(i.$$.fragment),h=b(),p(l.$$.fragment)},l(t){u(e.$$.fragment,t),a=k(t),u(o.$$.fragment,t),s=k(t),u(i.$$.fragment,t),h=k(t),u(l.$$.fragment,t)},m(t,n){d(e,t,n),g(t,a,n),d(o,t,n),g(t,s,n),d(i,t,n),g(t,h,n),d(l,t,n),x=!0},p(t,n){const _={};n&4&&(_.$$scope={dirty:n,ctx:t}),o.$set(_);const w={};n&4&&(w.$$scope={dirty:n,ctx:t}),l.$set(w)},i(t){x||(f(e.$$.fragment,t),f(o.$$.fragment,t),f(i.$$.fragment,t),f(l.$$.fragment,t),x=!0)},o(t){m(e.$$.fragment,t),m(o.$$.fragment,t),m(i.$$.fragment,t),m(l.$$.fragment,t),x=!1},d(t){t&&(c(a),c(s),c(h)),$(e,t),$(o,t),$(i,t),$(l,t)}}}function S(r){let e,a;return e=new C({props:{title:"Froggy",$$slots:{default:[O]},$$scope:{ctx:r}}}),{c(){p(e.$$.fragment)},l(o){u(e.$$.fragment,o)},m(o,s){d(e,o,s),a=!0},p(o,[s]){const i={};s&4&&(i.$$scope={dirty:s,ctx:o}),e.$set(i)},i(o){a||(f(e.$$.fragment,o),a=!0)},o(o){m(e.$$.fragment,o),a=!1},d(o){$(e,o)}}}function W(r){return[`<div><l></l><n></n></div>
<style>
  body {
    background: #293462;
    display: grid;
    place-items:center
  }
  div {
    margin-left: -75px;
    margin-top: 20px;
    width: 75px;
    height: 100px;
    border-radius: 50px 0 0 50px;
    background: radial-gradient(circle at 100% -125px, #FE5F55 0 195px, #A64942 0);
    position:relative;
    -webkit-box-reflect: right;
  }
  l {
    width: 30px;
    height: 30px;
    background:radial-gradient(#293462 5px, #FFF1C1 0);
    position:absolute;
    top: -25px;
    left: 15px;
    border: 10px solid #FE5F55;
    border-radius: 50%;
  }
  n {
    width:10px;
    height:10px;
    background:#293462;
    position:absolute;
    border-radius: 50%;
    top: 50px;
    left: 60px;
  }
</style>`,`<div><l></l></div>
<style>
  body {
    background: #293462;
    display: grid;
    place-items:center
  }
  div {
    margin-left: -75px;
    margin-top: 20px;
    width: 75px;
    height: 100px;
    border-radius: 50px 0 0 50px;
    background: radial-gradient(circle at 65px 55px, #293462 0 5px, #0000 0),
      radial-gradient(circle at 100% -125px, #FE5F55 0 195px, #A64942 0);
    position:relative;
    -webkit-box-reflect: right;
  }
  l {
    width: 30px;
    height: 30px;
    background:radial-gradient(#293462 5px, #FFF1C1 0);
    position:absolute;
    top: -25px;
    left: 15px;
    border: 10px solid #FE5F55;
    border-radius: 50%;
  }
</style>`]}class D extends I{constructor(e){super(),E(this,e,W,S,P,{})}}export{D as component};
