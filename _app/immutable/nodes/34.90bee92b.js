import{S as N,i as k,s as q,y as v,z as x,A as y,g as P,d as S,B as b,a as A,c as F,b as f,h as i,q as $,k as h,r as c,l as z,m as g,n as D,G as w,H as I}from"../chunks/index.0bb61340.js";import{N as L}from"../chunks/Narigo.7389b9d0.js";import{P as M,a as O}from"../chunks/PuzzlePageLayout.8fbea99b.js";function T(m){let e,s,o,n,t,r,p,u,d,_;return{c(){e=$("This is the first time I used "),s=h("code"),o=$("isolation: isolate"),n=$(`! From my understanding, it creates
		a new z-index stack and it allows me to put regular elements on top of each other, without
		having to `),t=h("code"),r=$("position: absolute"),p=$(` them. See
		`),u=h("a"),d=$("MDN for more information about isolation"),_=$("."),this.h()},l(a){e=c(a,"This is the first time I used "),s=z(a,"CODE",{});var l=g(s);o=c(l,"isolation: isolate"),l.forEach(i),n=c(a,`! From my understanding, it creates
		a new z-index stack and it allows me to put regular elements on top of each other, without
		having to `),t=z(a,"CODE",{});var E=g(t);r=c(E,"position: absolute"),E.forEach(i),p=c(a,` them. See
		`),u=z(a,"A",{href:!0,rel:!0});var C=g(u);d=c(C,"MDN for more information about isolation"),C.forEach(i),_=c(a,"."),this.h()},h(){D(u,"href","https://developer.mozilla.org/en-US/docs/Web/CSS/isolation"),D(u,"rel","external")},m(a,l){f(a,e,l),f(a,s,l),w(s,o),f(a,n,l),f(a,t,l),w(t,r),f(a,p,l),f(a,u,l),w(u,d),f(a,_,l)},p:I,d(a){a&&i(e),a&&i(s),a&&i(n),a&&i(t),a&&i(p),a&&i(u),a&&i(_)}}}function B(m){let e,s,o,n;return e=new O({props:{title:"Puzzle 53 solution",solution:m[0]}}),o=new L({props:{$$slots:{default:[T]},$$scope:{ctx:m}}}),{c(){v(e.$$.fragment),s=A(),v(o.$$.fragment)},l(t){x(e.$$.fragment,t),s=F(t),x(o.$$.fragment,t)},m(t,r){y(e,t,r),f(t,s,r),y(o,t,r),n=!0},p(t,r){const p={};r&2&&(p.$$scope={dirty:r,ctx:t}),o.$set(p)},i(t){n||(P(e.$$.fragment,t),P(o.$$.fragment,t),n=!0)},o(t){S(e.$$.fragment,t),S(o.$$.fragment,t),n=!1},d(t){b(e,t),t&&i(s),b(o,t)}}}function G(m){let e,s;return e=new M({props:{title:"Pastel Logo",$$slots:{default:[B]},$$scope:{ctx:m}}}),{c(){v(e.$$.fragment)},l(o){x(e.$$.fragment,o)},m(o,n){y(e,o,n),s=!0},p(o,[n]){const t={};n&2&&(t.$$scope={dirty:n,ctx:o}),e.$set(t)},i(o){s||(P(e.$$.fragment,o),s=!0)},o(o){S(e.$$.fragment,o),s=!1},d(o){b(e,o)}}}function H(m){return[""]}class J extends N{constructor(e){super(),k(this,e,H,G,q,{})}}export{J as component};
