import{s as m,a as $,c as y,i as c,d as f,l as b,m as S}from"../chunks/scheduler.wxh4t93s.js";import{S as _,i as x,b as o,d as l,m as d,a as p,t as u,e as h}from"../chunks/index.qiVYbOcq.js";import{N as v}from"../chunks/Narigo.Hd-thaQQ.js";import{P as w,a as z}from"../chunks/PuzzlePageLayout._2mI3XXM.js";function C(s){let t;return{c(){t=b(`Savvy Saturday Stylers Slaying CSSBattle.dev is the Saturday version of this. On Nov 18th, 2023,
		they played the "Poker Chip". I thought this should be easy to do with a dashed border, but when
		I tried that, it became clear that it's not easy to control the dashed border without using
		images. Images are forbidden in CSS battles, so this approach fell apart pretty quickly after
		seeing the dashes being a lot different to what we see here. I ended up using gradients once
		again... ðŸ˜…`)},l(n){t=S(n,`Savvy Saturday Stylers Slaying CSSBattle.dev is the Saturday version of this. On Nov 18th, 2023,
		they played the "Poker Chip". I thought this should be easy to do with a dashed border, but when
		I tried that, it became clear that it's not easy to control the dashed border without using
		images. Images are forbidden in CSS battles, so this approach fell apart pretty quickly after
		seeing the dashes being a lot different to what we see here. I ended up using gradients once
		again... ðŸ˜…`)},m(n,e){c(n,t,e)},d(n){n&&f(t)}}}function B(s){let t,n,e,r;return t=new z({props:{title:"Puzzle 154 solution",solution:s[0]}}),e=new v({props:{$$slots:{default:[C]},$$scope:{ctx:s}}}),{c(){o(t.$$.fragment),n=$(),o(e.$$.fragment)},l(a){l(t.$$.fragment,a),n=y(a),l(e.$$.fragment,a)},m(a,i){d(t,a,i),c(a,n,i),d(e,a,i),r=!0},p(a,i){const g={};i&2&&(g.$$scope={dirty:i,ctx:a}),e.$set(g)},i(a){r||(p(t.$$.fragment,a),p(e.$$.fragment,a),r=!0)},o(a){u(t.$$.fragment,a),u(e.$$.fragment,a),r=!1},d(a){a&&f(n),h(t,a),h(e,a)}}}function P(s){let t,n;return t=new w({props:{title:"Poker Chip",$$slots:{default:[B]},$$scope:{ctx:s}}}),{c(){o(t.$$.fragment)},l(e){l(t.$$.fragment,e)},m(e,r){d(t,e,r),n=!0},p(e,[r]){const a={};r&2&&(a.$$scope={dirty:r,ctx:e}),t.$set(a)},i(e){n||(p(t.$$.fragment,e),n=!0)},o(e){u(t.$$.fragment,e),n=!1},d(e){h(t,e)}}}function I(s){return[`<div></div>
<style>body{display:grid;place-items:center;background:#998235}
  div {
    width: 210px;
    height: 210px;
    border-radius: 50%;
    background:
      radial-gradient(#0B2429 60px, #FCBE5C 0 70px, #0000 0),
      linear-gradient(#0000 0 90px, #0B2429 0 120px, #0000 0),
      linear-gradient(90deg, #0000 0 90px, #0B2429 0 120px, #0000 0),
      linear-gradient(45deg, #0000 0 133px, #0B2429 0 163px, #0000 0),
      linear-gradient(-45deg, #0000 0 133px, #0B2429 0 163px, #0000 0),
      radial-gradient(#0B2429 80px, #FCBE5C 0 95px, #0B2429 0);
  }
</style>`]}class F extends _{constructor(t){super(),x(this,t,I,P,m,{})}}export{F as component};
